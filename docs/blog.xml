<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Juan Isaula</title>
<link>https://j-isaula.github.io/Web_JI/blog.html</link>
<atom:link href="https://j-isaula.github.io/Web_JI/blog.xml" rel="self" type="application/rss+xml"/>
<description>Technology and the Environment</description>
<generator>quarto-1.5.57</generator>
<lastBuildDate>Wed, 24 Jan 2024 06:00:00 GMT</lastBuildDate>
<item>
  <title>Tipos de Arquitecturas de Redes Neuronales</title>
  <dc:creator>Juan Isaula</dc:creator>
  <link>https://j-isaula.github.io/Web_JI/posts/Neural Network/</link>
  <description><![CDATA[ 




<p>Las arquitecturas de redes neuronales se refieren a los diseños estructurales y organizativos de redes neuronales artificiales (RNA). Estas arquitecturas determinan cómo se organiza la red, incluida la cantidad de capas, la cantidad de neuronas en cada capa, las conexiones entre neuoronas y las funciones de activación utilizadas. Se forman diferentes arquitecturas de redes neuronales alterando estos componentes estructurales para adaptarse a tareas o desafíos específicos. Si desea conocer los tipos de arquitectura de redes neuronales que debe conocer, este artículo es para usted. En este artículo, le explicaré los tipos de arquitecturas de redes neuronales en <code>Machine Learning</code> y cuándo elegirlas.</p>
<section id="fundamentos-previos-a-la-comprensión-de-redes-neuronales" class="level2">
<h2 class="anchored" data-anchor-id="fundamentos-previos-a-la-comprensión-de-redes-neuronales">Fundamentos previos a la comprensión de Redes Neuronales</h2>
<section id="función-de-activación" class="level3">
<h3 class="anchored" data-anchor-id="función-de-activación">Función de Activación</h3>
<p>Una función de activación es una función que se agrega a una red neuronal para ayudar a la red a aprender dependencias no lineales complejas. Una función de activación típica debe ser diferenciable y continua en todas partes. A continuación proporcionaré algunos ejemplos de funciones de activación utilizando la biblioteca <a href="https://pytorch.org/">PyTorch</a>.</p>
<section id="función-relu" class="level4">
<h4 class="anchored" data-anchor-id="función-relu">Función ReLU</h4>
<p><code>ReLU</code> o la función ReLU realiza una operación simple: <img src="https://latex.codecogs.com/png.latex?y%20=%20%5Cmax%20(0,%20x)">. Aquí te proporcionó un ejemplo de uso de la función ReLU utilizando <code>PyTorch.</code></p>
<div id="16d59255" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch</span>
<span id="cb1-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch.nn <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> nn</span>
<span id="cb1-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> matplotlib.pyplot <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> plt</span>
<span id="cb1-4"></span>
<span id="cb1-5">x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.linspace(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>,steps<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>)</span>
<span id="cb1-6"></span>
<span id="cb1-7">relu <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.nn.ReLU()</span>
<span id="cb1-8"></span>
<span id="cb1-9">y <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> relu(x)</span>
<span id="cb1-10">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ReLU"</span>)</span>
<span id="cb1-11">plt.plot(x.tolist(), y.tolist())</span>
<span id="cb1-12">plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/index_files/figure-html/cell-2-output-1.png" width="566" height="431" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="función-sigmoidea" class="level4">
<h4 class="anchored" data-anchor-id="función-sigmoidea">Función Sigmoidea</h4>
<p>Es una de las funciones de activación no lineal más comunes. La función sigmoidea se representa matemáticamente como:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csigma(x)%20=%20%5Cfrac%7B1%7D%7B1%20+%20e%5Ex%7D%0A"></p>
<p>Al igual que <code>ReLU</code>, la función <img src="https://latex.codecogs.com/png.latex?%5Csigma"> se puede construir simplemente usando <code>PyTorch</code>.</p>
<div id="6922fc6e" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch</span>
<span id="cb2-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch.nn <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> nn</span>
<span id="cb2-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> matplotlib.pyplot <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> plt</span>
<span id="cb2-4"></span>
<span id="cb2-5">x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.linspace(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>,steps<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>)</span>
<span id="cb2-6"></span>
<span id="cb2-7">sigmoid <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.nn.Sigmoid()</span>
<span id="cb2-8"></span>
<span id="cb2-9">y <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sigmoid(x)</span>
<span id="cb2-10">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Sigmoidea"</span>)</span>
<span id="cb2-11">plt.plot(x.tolist(), y.tolist())</span>
<span id="cb2-12">plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/index_files/figure-html/cell-3-output-1.png" width="571" height="431" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="función-tanh" class="level4">
<h4 class="anchored" data-anchor-id="función-tanh">Función Tanh</h4>
<p>La función tangente hiperbólica es similar a la función sigmoidea, pero devuelve valores en el rango <img src="https://latex.codecogs.com/png.latex?(-1,1)">. El beneficio de <code>Tanh</code> sobre <img src="https://latex.codecogs.com/png.latex?%5Csigma"> es que las entradas negativas se asignarán estrictamente a negativa, y las entradas positivas se asignarán estrictamente a positivas:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctanh(x)%20=%20%5Cfrac%7Be%5Ex%20-%20e%5E%7B-x%7D%7D%7Be%5Ex%20+%20e%5E%7B-x%7D%7D%0A"></p>
<div id="b7f6a35a" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch</span>
<span id="cb3-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> matplotlib.pyplot <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> plt</span>
<span id="cb3-3"></span>
<span id="cb3-4">x<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>torch.linspace(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>, steps <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>)</span>
<span id="cb3-5">tanh <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.nn.Tanh()</span>
<span id="cb3-6">y <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> tanh(x)</span>
<span id="cb3-7"></span>
<span id="cb3-8">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Tanh'</span>)</span>
<span id="cb3-9">plt.plot(x.tolist(),y.tolist())</span>
<span id="cb3-10">plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/index_files/figure-html/cell-4-output-1.png" width="590" height="431" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Las funciones de activación no lineales, como la <img src="https://latex.codecogs.com/png.latex?%5Csigma"> y <img src="https://latex.codecogs.com/png.latex?%5Ctanh"> sufren de un gran problema computacional llamado problema de <strong><em>fuga de gradiente.</em></strong></p>
<p>La <strong><em>fuga de gradiente</em></strong> hace que sea muy difícil entrenar y ajustar los parámetros de las capas iniciales en la red. Este problema empeora a medida que aumenta el número de capas en la red.</p>
<p>La fuga de gradiente es la causa principal que hace que las activaciones sigmoideas o Tanh no sean adecuadas para los modelos de Deep Learning (aprendizaje profundo). La función de activación <code>ReLU</code> no sufre de gradiente de fuga porque la derivada siempre es 1 para entradas positivas. Así que siempre considere usar <code>ReLU</code> como la función de activación en los primeros borradores del diseño de su modelo.<br>
<br>
La creación de una arquitectura de red neuronal que se adapte más a un problema en particular es un arte. Existe una dirección de estudio separada en el aprendizaje profundo llamado <em><code>Búsqueda de arquitectura neural</code></em>, que automatiza la ingeniería de arquitectura de red: <a href="https://lilianweng.github.io/lil-log/2020/08/06/neural-architecture-search.html." class="uri">https://lilianweng.github.io/lil-log/2020/08/06/neural-architecture-search.html.</a> Pero incluso estos motores de búsqueda no pueden competir con las habilidades heurísticas humanas en el diseño todavía. Existen algunas técnicas que aumentan la probabilidad de mejorar el rendimiento de la red neuronal. Por supuesto, estas técnicas no garantizan la mejora en todos los casos. A veces incluso pueden empeorar el rendimiento de la red neuronal. Pero es probable que desarrolle una arquitectura de modelo robusta siguiendo estos enfoques.</p>
</section>
</section>
<section id="funciones-de-pérdida-y-optimización" class="level3">
<h3 class="anchored" data-anchor-id="funciones-de-pérdida-y-optimización">Funciones de Pérdida y Optimización</h3>
<section id="funciones-de-pérdida" class="level4">
<h4 class="anchored" data-anchor-id="funciones-de-pérdida">Funciones de Pérdida</h4>
<p>La función de pérdida calculará un error de red en cada iteración, mientras que la función de optimización determina <em>“cómo y en qué dirección cambiar los parámetros de peso”.</em></p>
<p>Hay una cantidad diversa de funciones de pérdida, cada una de ellas está destinada a una tarea en particular. Para el análisis de series de tiempo, hay tres funciones de pérdida principales:</p>
<ul>
<li><p><strong><em>Pérdida absoluta (L1):</em></strong> La pérdida absoluta es la métrica más simple de la distancia entre dos vectores:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Aabsolute%20loss%20=%20%5Cfrac%7B%5Csum%20%7Cy_%7Bactual%7D%20-%20y_%7Bpredicci%C3%B3n%7D%7C%7D%7Bn%7D%0A"></p>
<p>En <code>PyTorch</code>, la función de pérdida absoluta se implementa de la siguiente manera:</p>
<div id="6103198e" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1">a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.tensor([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>]).<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>()</span>
<span id="cb4-2">b <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.tensor([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>]).<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>()</span>
<span id="cb4-3">abs_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.nn.L1Loss()</span>
<span id="cb4-4">abs_error <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> abs_loss(a,b)</span>
<span id="cb4-5"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f'abs: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>abs_error<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>item()<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>abs: 1.5</code></pre>
</div>
</div></li>
<li><p><strong><em>Error cuadrático medio (MSE)</em></strong> <strong><em>(L2):</em></strong> Es la función de pérdida más utilizada para los problemas de predicción de series de tiempo:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Amean%5C_squared%5C_error%20=%20%20%5Cfrac%7B%5Csum(y_%7Bactual%7D%20-%20y_%7Bpredicted%7D)%5E2%7D%7Bn%7D%0A"></p></li>
<li><p><strong><em>Pérdida suave (L1):</em></strong> es algo intermedio entre las funciones de pérdida absoluta y MSE. La pérdida absoluto (L1) es menos sensible a los valores atípicos que MSE:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Asmooth%5C_loss(y%5E%7B%5Cprime%7D,y)%20=%20%5Cfrac%7B1%7D%7Bn%7D%5Csum%20z_i%0A"></p>
<p>donde <img src="https://latex.codecogs.com/png.latex?y"> es valor real, <img src="https://latex.codecogs.com/png.latex?y"> se predice, <img src="https://latex.codecogs.com/png.latex?z_i"> se define como:</p>
<p><img src="https://latex.codecogs.com/png.latex?%20z%20=%0A%5Cbegin%7Bequation%7D%0A%5Cbegin%7Bmatrix%7D%0A%20%20%5Cfrac%7B0.5(y_%7Bi%7D%5E%7B%5Cprime%7D%20-%20y_i)%5E2%7D%7B%5Cbeta%7D,%20&amp;%20%7Cy_%7Bi%7D%5E%7B%5Cprime%7D%20-%20y_i%7C%20%3C%20%5Cbeta%5C%5C%20%20%0A%7Cy_%7Bi%7D%5E%7B%5Cprime%7D%20-%20y_i%7C%20-%200.5%5Cbeta,%20&amp;%20otro%5C_caso%0A%20%20%5Cend%7Bmatrix%7D%0A%5Cend%7Bequation%7D%0A"></p></li>
</ul>
<p>La función de pérdida de L1 suave tiene un parámetro <img src="https://latex.codecogs.com/png.latex?%5Cbeta">, es igual a 1 por defecto.</p>
</section>
<section id="optimizador" class="level4">
<h4 class="anchored" data-anchor-id="optimizador">Optimizador</h4>
<p>El objetivo principal de un optimizador es cambiar los parámetros de pesos del modelo para minimizar la función de pérdida. La selección de un optimizador adecuado depende completamente de la arquitectura de la red neuronal y los datos sobre los que ocurre el entrenamiento.</p>
<ul>
<li><p><code>Adagrad:</code> es un algoritmo de optimización basado en gradiente que adapta la tasa de aprendizaje a los parámetros. Realiza actualizaciones más pequeñas para los parámetros asociados con características frecuentes y actualizaciones más grandes para parámetros asociados con características raras.</p></li>
<li><p><code>Adadelta</code> es la versión avanzada del algoritmo de Adagrad. Adadelta busca minimizar su tasa de aprendizaje agresiva y monotónica que disminuye. En lugar de acumular todos los gradientes pasados.</p></li>
<li><p><code>Adam</code> es otro método de optimización que calcula las tasas de aprendizaje adaptativo para cada parámetro. Además de guardar un promedio exponencialmente en descomposición de gradientes cuadrados anteriores como Adadelta, Adam también mantiene un promedio exponencialmente de disminución de gradientes anteriores.</p></li>
</ul>
</section>
</section>
</section>
<section id="tipos-de-redes-neuronales" class="level2">
<h2 class="anchored" data-anchor-id="tipos-de-redes-neuronales">Tipos de Redes Neuronales</h2>
<p>Comenzaremos explorando algunas de las arquitecturas de redes neuronales más eficientes para el pronóstico de series de tiempo. Nos centraremos en la implementación de redes neuronales recurrentes (RNN), unidad recurrentes cerradas (GRU), redes de memoria a largo plazo (LSTM). Comprender los principios básicos de las RNN será una buena base para su aplicación directa y dominar otras arquitecturas similares. Trataremos de cubrir la lógica y el núcleo de cada arquitectura, su aplicación práctica y pros y contras.</p>
<p>Discutiremos los siguientes temas:</p>
<ul>
<li><p>Recurrent neural network (RNN)</p></li>
<li><p>Gated recurrent unit network (GRU)</p></li>
<li><p>Long short-term memory network (LSTM)</p></li>
</ul>
<section id="recurrent-neural-network-rnn" class="level3">
<h3 class="anchored" data-anchor-id="recurrent-neural-network-rnn">Recurrent Neural Network (RNN)</h3>
<p>RNN <em>(Red Neuronal Recurrente Estándar)</em> tiene un concepto de un estado oculto. Un estado oculto puede tratarse como memoria interna. El estado oculto no intenta recordar todos los valores pasados de la secuencia sino solo su efecto. Debido a la memoria interna, las RNN pueden recordar cosas importantes sobre su entrada, lo que les permite ser muy preciosos para predecir valores futuros.</p>
<p>Estudiemos la teoría de RNN de una manera más formal. En RNN, la secuencia de entrada se representa a traves de un bucle. Cuando toma una decisión, considera la entrada actual y también lo que ha aprendido de las entradas que recibio anteriormente. Veamos el gráfico computacional de RNN para comprender esta lógica:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/Figure 4.3.png" class="img-fluid figure-img"></p>
<figcaption>Gráfico Computacional de RNN</figcaption>
</figure>
</div>
<p>donde,</p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?x_1,%20x_2,%20.%20.%20.%20,%20x_n"> son la secuencia de entrada.</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?h_i"> es el estado oculto. <img src="https://latex.codecogs.com/png.latex?h_i"> es un vector de longitud <img src="https://latex.codecogs.com/png.latex?h">.</p></li>
<li><p><code>RNN Cell</code> representa la capa de red neuronal que calcula la siguiente función: <img src="https://latex.codecogs.com/png.latex?h_t%20=%20%5Ctanh(W_%7Bih%7Dx_t%20+%20b_%7Bih%7D%20+%20W_%7Bhh%7Dh_%7B(t-1)%7D%20+%20b_%7Bhh%7D)"></p></li>
</ul>
<p>Podemos ver a detalle la RNN Cell:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/Figure 4.4.png" class="img-fluid figure-img"></p>
<figcaption>Gráfico computacional de RNN Cell</figcaption>
</figure>
</div>
<p>La RNN Cell combina información sobre el valor actual de la secuencia <img src="https://latex.codecogs.com/png.latex?x_i"> y el estado previamente oculto <img src="https://latex.codecogs.com/png.latex?h_%7Bi-1%7D">. La RNN Cell, devuelve un estado oculto actualizado <img src="https://latex.codecogs.com/png.latex?h_i"> después de aplicar la función de activación.</p>
<p>La RNN tiene los siguientes parámetros, que se ajustan durante el entrenamiento:</p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?W_%7Bih%7D"> pesos ocultos de entrada</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?b_%7Bih%7D"> sesgos oculto de entrada</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?W_%7Bhh%7D"> pesos ocultos - ocultos</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?B_%7Bhh%7D"> sesgos oculto - oculto</p></li>
</ul>
<p><strong><em>Nota:</em></strong> <em>Un error común ocurre cuando los subíndices en los parámetros RNN</em> <img src="https://latex.codecogs.com/png.latex?(W_%7Bih%7D,%20b_%7Bih%7D,%20W_%7Bhh%7D,%20b_%7Bhh%7D)"> <em>se interpretan como una dimensión de índice o tensor. No, son solo la abreviatura de entrada-oculto</em> <img src="https://latex.codecogs.com/png.latex?(h_%C3%AD)"> <em>y oculto-oculto</em> <img src="https://latex.codecogs.com/png.latex?(h)"><em>. El mismo principio aplica a los parámetros de otros modelos: <code>GRU</code> y <code>LSTM</code>.</em></p>
<p>En ocasiones, los cientificos de datos utilizan la siguiente representación de las RNN:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/Figure 4.5.png" class="img-fluid figure-img"></p>
<figcaption>Visualización alternativa de RNN</figcaption>
</figure>
</div>
<p>El gráfico que se muestra puede dar lugar a algunos malentendidos, y estoy tratando de evitar esto. Pero si este tipo de gráfico se adapta a tu intuición, entonces úsalo sin ninguna duda.<br>
</p>
<p>Ahora estamos listos para examinar una implementación de RNN utilizando <a href="https://pytorch.org/">PyTorch</a></p>
<div id="025946b0" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch.nn <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> nn</span>
<span id="cb6-2"></span>
<span id="cb6-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> RNN(nn.Module):</span>
<span id="cb6-4"></span>
<span id="cb6-5">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>,</span>
<span id="cb6-6">                 hidden_size,</span>
<span id="cb6-7">                 in_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,</span>
<span id="cb6-8">                 out_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):</span>
<span id="cb6-9">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">super</span>(RNN, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>).<span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>()</span>
<span id="cb6-10">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.rnn <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.RNN(</span>
<span id="cb6-11">            input_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> in_size,</span>
<span id="cb6-12">            hidden_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> hidden_size,</span>
<span id="cb6-13">            batch_first <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>)</span>
<span id="cb6-14">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.fc <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.Linear(hidden_size, out_size)</span>
<span id="cb6-15"></span>
<span id="cb6-16">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> forward(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, x, h <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>):</span>
<span id="cb6-17">        out, _ <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.rnn(x, h)</span>
<span id="cb6-18">        last_hidden_states <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> out[:, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]</span>
<span id="cb6-19">        out <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.fc(last_hidden_states)</span>
<span id="cb6-20">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> out, last_hidden_states</span></code></pre></div>
</div>
<p>Note que nuestro modelo devuelve dos salidas: predicción y estado oculto. Es crucial reutilizar los estados ocultos durante la evaluación RNN. Utilizaremos conjuntos de datos de consumo de energía por hora ( <a href="https://www.kaggle.com/robikscube/Hourly-energy-Consumed" class="uri">https://www.kaggle.com/robikscube/Hourly-energy-Consumed</a>) para la implementación de RNN.</p>
<div id="343ed23b" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> pandas <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> pd</span>
<span id="cb7-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch</span>
<span id="cb7-3"></span>
<span id="cb7-4">df <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> pd.read_csv(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'AEP_hourly.csv'</span>)</span>
<span id="cb7-5">ts <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> df[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'AEP_MW'</span>].astype(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>).values.reshape(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)[<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3000</span>:]</span>
<span id="cb7-6"></span>
<span id="cb7-7"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> matplotlib.pyplot <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> plt</span>
<span id="cb7-8"></span>
<span id="cb7-9">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'AEP Hourly'</span>)</span>
<span id="cb7-10">plt.plot(ts[:<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">500</span>])</span>
<span id="cb7-11">plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/index_files/figure-html/cell-7-output-1.png" width="592" height="431" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Podemos ver en que esta es una serie de tiempo realmente complicada. Tiene varios factores de estacionalidad con picos apenas predecibles.</p>
<p>A continuación, voy a mostrarte como se desempeña RNN en la serie de tiempo AEP Hourly:</p>
<div id="2280a522" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> copy</span>
<span id="cb8-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> random</span>
<span id="cb8-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> sys</span>
<span id="cb8-4"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb8-5"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> matplotlib.pyplot <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> plt</span>
<span id="cb8-6"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch</span>
<span id="cb8-7"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sklearn.preprocessing <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> MinMaxScaler</span>
<span id="cb8-8"></span>
<span id="cb8-9">random.seed(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb8-10">torch.manual_seed(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb8-11"></span>
<span id="cb8-12"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Parametros globales</span></span>
<span id="cb8-13"></span>
<span id="cb8-14"></span>
<span id="cb8-15">features <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">240</span></span>
<span id="cb8-16"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Longitud del conjunto de datos de prueba</span></span>
<span id="cb8-17">test_ts_len <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">300</span></span>
<span id="cb8-18"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># tamaño del estado oculto</span></span>
<span id="cb8-19">rnn_hidden_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">24</span></span>
<span id="cb8-20"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># tasa de aprendizaje de optimizador</span></span>
<span id="cb8-21">learning_rate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.02</span></span>
<span id="cb8-22"></span>
<span id="cb8-23">training_epochs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">500</span></span>
<span id="cb8-24"></span>
<span id="cb8-25"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> sliding_window(ts, features):</span>
<span id="cb8-26">    X <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb8-27">    Y <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb8-28"></span>
<span id="cb8-29">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(features <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(ts) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):</span>
<span id="cb8-30">        X.append(ts[i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> (features <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>])</span>
<span id="cb8-31">        Y.append([ts[i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]])</span>
<span id="cb8-32"></span>
<span id="cb8-33">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> X, Y</span>
<span id="cb8-34"></span>
<span id="cb8-35"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> get_training_datasets(ts, features, test_len):</span>
<span id="cb8-36">    X, Y <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sliding_window(ts, features)</span>
<span id="cb8-37"></span>
<span id="cb8-38">    X_train, Y_train, X_test, Y_test <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> X[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>test_len],<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb8-39">                                       Y[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>test_len],<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb8-40">                                       X[<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>test_len:],<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb8-41">                                       Y[<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>test_len:]</span>
<span id="cb8-42"></span>
<span id="cb8-43">    train_len <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">round</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(ts) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>)</span>
<span id="cb8-44"></span>
<span id="cb8-45">    X_train, X_val, Y_train, Y_val <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> X_train[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:train_len],<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb8-46">                                     X_train[train_len:],<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb8-47">                                     Y_train[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:train_len],<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb8-48">                                     Y_train[train_len:]</span>
<span id="cb8-49"></span>
<span id="cb8-50">    x_train <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.tensor(data <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> X_train).<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>()</span>
<span id="cb8-51">    y_train <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.tensor(data <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Y_train).<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>()</span>
<span id="cb8-52"></span>
<span id="cb8-53">    x_val <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.tensor(data <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> X_val).<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>()</span>
<span id="cb8-54">    y_val <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.tensor(data <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Y_val).<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>()</span>
<span id="cb8-55"></span>
<span id="cb8-56">    x_test <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.tensor(data <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> X_test).<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>()</span>
<span id="cb8-57">    y_test <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.tensor(data <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Y_test).<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>()</span>
<span id="cb8-58"></span>
<span id="cb8-59">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> x_train, x_val, x_test,<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb8-60">           y_train.squeeze(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>), y_val.squeeze(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>), y_test.squeeze(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb8-61">           </span>
<span id="cb8-62"></span>
<span id="cb8-63"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Preparando datos para entrenamiento</span></span>
<span id="cb8-64">scaler <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> MinMaxScaler()</span>
<span id="cb8-65">scaled_ts <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> scaler.fit_transform(ts)</span>
<span id="cb8-66">x_train, x_val, x_test, y_train, y_val, y_test <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=\</span></span>
<span id="cb8-67">    get_training_datasets(scaled_ts, features, test_ts_len)</span>
<span id="cb8-68">    </span>
<span id="cb8-69"></span>
<span id="cb8-70"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Inicialización del modelo </span></span>
<span id="cb8-71">model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> RNN(hidden_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> rnn_hidden_size)</span>
<span id="cb8-72">model.train()</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre><code>RNN(
  (rnn): RNN(1, 24, batch_first=True)
  (fc): Linear(in_features=24, out_features=1, bias=True)
)</code></pre>
</div>
</div>
<div id="e2c648e1" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Entrenamiento</span></span>
<span id="cb10-2">optimizer <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.optim.Adam(params <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model.parameters(), lr <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> learning_rate)</span>
<span id="cb10-3">mse_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.nn.MSELoss()</span>
<span id="cb10-4"></span>
<span id="cb10-5">best_model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span></span>
<span id="cb10-6">min_val_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sys.maxsize</span>
<span id="cb10-7"></span>
<span id="cb10-8">training_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb10-9">validation_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb10-10"></span>
<span id="cb10-11"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> t <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(training_epochs):</span>
<span id="cb10-12"></span>
<span id="cb10-13">    prediction, _ <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model(x_train)</span>
<span id="cb10-14">    loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> mse_loss(prediction, y_train)</span>
<span id="cb10-15"></span>
<span id="cb10-16">    optimizer.zero_grad()</span>
<span id="cb10-17">    loss.backward()</span>
<span id="cb10-18">    optimizer.step()</span>
<span id="cb10-19"></span>
<span id="cb10-20">    val_prediction, _ <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model(x_val)</span>
<span id="cb10-21">    val_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> mse_loss(val_prediction, y_val)</span>
<span id="cb10-22"></span>
<span id="cb10-23">    training_loss.append(loss.item())</span>
<span id="cb10-24">    validation_loss.append(val_loss.item())</span>
<span id="cb10-25"></span>
<span id="cb10-26">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> val_loss.item() <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> min_val_loss:</span>
<span id="cb10-27">        best_model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> copy.deepcopy(model)</span>
<span id="cb10-28">        min_val_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> val_loss.item()</span>
<span id="cb10-29"></span>
<span id="cb10-30">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> t <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">50</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:</span>
<span id="cb10-31">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f'epoch </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>t<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: train - </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">round</span>(loss.item(), <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>)<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">, '</span></span>
<span id="cb10-32">              <span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f'val: - </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">round</span>(val_loss.item(), <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>)<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>epoch 0: train - 0.377, val: - 0.0866
epoch 50: train - 0.0061, val: - 0.0133
epoch 100: train - 0.0021, val: - 0.0044
epoch 150: train - 0.0018, val: - 0.0034
epoch 200: train - 0.0015, val: - 0.003
epoch 250: train - 0.0014, val: - 0.0027
epoch 300: train - 0.0013, val: - 0.0026
epoch 350: train - 0.0012, val: - 0.0025
epoch 400: train - 0.0012, val: - 0.0024
epoch 450: train - 0.0012, val: - 0.0024</code></pre>
</div>
</div>
<p>Y aquí llegamos al punto más difícil. Debe pasar el estado oculto al modelo RNN cuando lo evalua. La forma más sencilla de calentar el estado oculto es ejecutar el modelo en los datos de validación una vez y pasar un estado oculto cálido a través de cada iteración y por último evaluamos el modelo que construimos en el conjunto de datos de prueba.</p>
<div id="788a58ac" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb12" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1">best_model.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">eval</span>()</span>
<span id="cb12-2">_, h_list <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> best_model(x_val)</span>
<span id="cb12-3"></span>
<span id="cb12-4">h <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (h_list[<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, :]).unsqueeze(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span>
<span id="cb12-5"></span>
<span id="cb12-6"></span>
<span id="cb12-7">predicted <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb12-8"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> test_seq <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> x_test.tolist():</span>
<span id="cb12-9">    x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.Tensor(data <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [test_seq])</span>
<span id="cb12-10"> </span>
<span id="cb12-11">    y, h <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> best_model(x, h.unsqueeze(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>))</span>
<span id="cb12-12">    unscaled <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> scaler.inverse_transform(np.array(y.item()).reshape(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>))[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>][<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb12-13">    predicted.append(unscaled)</span>
<span id="cb12-14"></span>
<span id="cb12-15">real <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> scaler.inverse_transform(y_test.tolist())</span>
<span id="cb12-16">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Conjunto de datos prueba - RNN"</span>)</span>
<span id="cb12-17">plt.plot(real, label <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'real'</span>)</span>
<span id="cb12-18">plt.plot(predicted, label <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'predicción'</span>)</span>
<span id="cb12-19">plt.legend()</span>
<span id="cb12-20">plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/index_files/figure-html/cell-10-output-1.png" width="592" height="431" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>RNN muestra un gran rendimiento en el conjunto de datos de prueba. El modelo que hemos entrenado predice picos estacionales con mucha precisión.</p>
<p>Y finalmente, examinamos el proceso de entrenamiento en sí.</p>
<div id="6efc6836" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb13" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Desempeño RNN'</span>)</span>
<span id="cb13-2">plt.yscale(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'log'</span>)</span>
<span id="cb13-3">plt.plot(training_loss, label <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Entrenamiento'</span>)</span>
<span id="cb13-4">plt.plot(validation_loss, label <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'validación'</span>)</span>
<span id="cb13-5">plt.ylabel(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Loss'</span>)</span>
<span id="cb13-6">plt.xlabel(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Epoch'</span>)</span>
<span id="cb13-7">plt.legend()</span>
<span id="cb13-8">plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/index_files/figure-html/cell-11-output-1.png" width="599" height="450" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>El proceso del entrenamiento es suave sin picos agudos e impredecibles.</p>
<p>Ahora, podemos establecer con confianza la promesa y la efectividad de la aplicación de RNN a los problemas de pronósticos de la serie temporal.</p>
<p>A pesar de todas las ventajas de RNN, tiene desventajas significativas:</p>
<ul>
<li><p>Debido a la complejidad computacional, sufren problemas de gradiente de fuga. El proceso de entrenamiento se vuelve demasiado lento. El problema del gradiente de fuga es un problema común a todas las RNN.</p></li>
<li><p>El estado oculto se actualiza en cada iteración, lo que dificulta el almacenamiento de información a largo plazo en RNN. Las arquitecturas <code>GRU</code> y <code>LSTM</code> resuelven este problema. Tienen enfoques similares sobre cómo almacenar información a largo plazo.</p></li>
</ul>
</section>
<section id="gated-recurrent-unit-network-gru" class="level3">
<h3 class="anchored" data-anchor-id="gated-recurrent-unit-network-gru">Gated recurrent unit network (GRU)</h3>
<p>La GRU es es una versión avanzada de la RNN clásica. El propósito principal de GRU es almacenar información a largo plazo. En breve exploraremos como GRU logra esto.</p>
<p>La forma más fácil de almacenar información a largo plazo en un estado oculto es restringir las actualizaciones ocultas sobre cada iteración. Este enfoque evitará sobrescribir información importante a largo plazo.</p>
<p>Puede encontrar la siguiente definición de GRU en internet:</p>
<p>Se comienza calculando la puerta de actualización <img src="https://latex.codecogs.com/png.latex?z_t"> para el peso de tiempo <img src="https://latex.codecogs.com/png.latex?t"> usando la fórmula:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Beqnarray*%7D%0Az_%7Bt%7D%20&amp;=&amp;%20%5Csigma(W%5E%7Bz%7Dx_t%20+%20U%5E%7Bz%7Dh_%7Bt-1%7D)%20%5Chspace%7B1cm%7D%20%5Cmbox%7BPuerta%20de%20actualizaci%C3%B3n%7D%5C%5C%5B0.2cm%5D%0A%5Cend%7Beqnarray*%7D%0A"></p>
<p>lo que sucede aquí es que cuando <img src="https://latex.codecogs.com/png.latex?x_t"> se conecta a la unidad de red, se multiplica por su propio peso <img src="https://latex.codecogs.com/png.latex?W%5E%7Bz%7D">. Lo mismo ocurre con <img src="https://latex.codecogs.com/png.latex?h_%7Bt-1%7D">, que contiene la información de las unidades <img src="https://latex.codecogs.com/png.latex?t-1"> anteriores y se múltiplica por su propio peso <img src="https://latex.codecogs.com/png.latex?U%5E%7Bz%7D">. Ambos resultados se suman y se aplica una función de activación sigmoidea <img src="https://latex.codecogs.com/png.latex?(%5Csigma)"> para acotar el resultado entre 0 y 1.</p>
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/fig_gru_1.png" class="img-fluid"></p>
<p>La puerta de actualización ayuda al modelo a determinar cuánta información pasada (de pasos de tiempo anteriores) debe transmitirse al futuro. Esto es muy poderoso porque el modelo puede decidir copiar toda la la información del pasado y eliminar el riesgo de que desaparezca el problema de fuga del gradiente.</p>
<p>Luego continuamos con Restablecer puerta:</p>
<p>Básicamente, esta puerta se utiliza desde el modelo para decidir cuánta información pasada se debe olvidar. Para calcularlo utilizamos:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ar_t%20=%20%5Csigma(W%5E%7Br%7Dx_t%20+%20U%5E%7Br%7Dh_%7Bt-1%7D)%5Chspace%7B1cm%7D%20%5Cmbox%7BRestablecer%20puerta%7D%0A"></p>
<p>Esta fórmula es la misma que la de la puerta de actualización. La diferencia viene en los pesos y el uso de la puerta, que veremos en un momento.</p>
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/fig_2_gru.png" class="img-fluid"></p>
<p>Como antes, conectamos <img src="https://latex.codecogs.com/png.latex?h_%7Bt-1%7D%20-%20%5Cmbox%7Blinea%20azul%7D"> y <img src="https://latex.codecogs.com/png.latex?x_%7Bt%7D%20-%20%5Cmbox%7Blinea%20violeta%7D">, los multiplicamos con sus pesos correspondientes, sumamos los resultados y aplicamos la función sigmoidea.</p>
<p><strong><em>Contenido de la memoria actual:</em></strong></p>
<p>veamos como afectarán exactamente las puertaas al resultado final. Primero, comenzamos con el uso de la puerta de reinicio. Introducimos un nuevo contenido de memoria que utilizará la puerta de reinicio para almacenar la información del pasado. Se calcula de la siguiente manera:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ah_%7Bt%7D%5E%7B%5Cprime%7D%20=%20tanh(Wx_%7Bt%7D%20+%20r_%7Bt%7D%5Codot%20U%20h_%7Bt-1%7D)%0A"></p>
<ol type="1">
<li><p>Multiplique la entrada <img src="https://latex.codecogs.com/png.latex?x_t"> con un peso <img src="https://latex.codecogs.com/png.latex?W"> y <img src="https://latex.codecogs.com/png.latex?h_%7Bt-1%7D"> con un peso <img src="https://latex.codecogs.com/png.latex?U">.</p></li>
<li><p>Calcule el producto de Hadamard (por elementos) entre la puerta de reinicio <img src="https://latex.codecogs.com/png.latex?r_t"> y <img src="https://latex.codecogs.com/png.latex?Uh_%7Bt-1%7D">. Eso determinará qué eliminar de los pasos de tiempo anterior. Digamos que tenemos un problema de análisis de sentimientos para determinar la opinión de una persona sobre un libro a partir de una reseña que escribió. El texto comienza con <em>“Este es un libro de fantasía que ilustra…”</em> y después de un par de párrafos termina con <em>“No disfruté mucho el libro porque creo que captura demasiados detalles”. Para determinar el nivel general de satisfacción con el libro sólo necesitamos la última parte de la reseña. En ese caso, a medida que la red neuronal se acerque al final del texto, aprenderá a asignar un vector</em> <img src="https://latex.codecogs.com/png.latex?r_t"> cercano a 0, eliminando el pasado y centrándose solo en las últimas oraciones.</p></li>
<li><p>Resuma los resultados de los pasos 1 y 2.</p></li>
<li><p>Aplicar la función de activación no lineal tanh.</p></li>
</ol>
<p>Puedes ver claramente los pasos aquí:</p>
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/fig_3_gru.png" class="img-fluid"></p>
<p>Hacemos una multiplicación por elementos de <img src="https://latex.codecogs.com/png.latex?h_%7Bt-1%7D%20-%20%5Cmbox%7Bl%C3%ADnea%20azul%7D"> y <img src="https://latex.codecogs.com/png.latex?r_t%20-%20%5Cmbox%7Bl%C3%ADnea%20naranja%7D"> y luego sumamos el resultado - linea rosa con la entrada <img src="https://latex.codecogs.com/png.latex?x_t%20-"> línea morada. Finalmente, tanh se usa para producir <img src="https://latex.codecogs.com/png.latex?h_%7Bt%7D%5E%7B%5Cprime%7D:"> línea verde brillante.</p>
<p><strong><em>Memoria final en el paso de tiempo actual</em></strong></p>
<p>Como último paso, la red necesita calcular <img src="https://latex.codecogs.com/png.latex?h_%7Bt%7D">, el vector que contiene información para la unidad actual y la transmite a la red. Para hacer eso, se necesita la puerta de actualización. Determina qué recopilar el contenido de la memoria actual <img src="https://latex.codecogs.com/png.latex?(h_t%5E%7B%5Cprime%7D)"> y qué de los pasos anteriores <img src="https://latex.codecogs.com/png.latex?(h_%7B(t-1)%7D)">. Eso se hace de la siguiente manera:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ah_t%20=%20z_t%5Codot%20h_%7Bt-1%7D%20+%20(1%20-%20z_t)%5Codot%20h_%7Bt%7D%5E%7B%5Cprime%7D%0A"></p>
<ol type="1">
<li><p>Aplique la multiplicación por elementos a la puerta de actualización <img src="https://latex.codecogs.com/png.latex?z_t"> y <img src="https://latex.codecogs.com/png.latex?h_%7B(t-1)%7D">.</p></li>
<li><p>Aplique la multiplicación por elementos a <img src="https://latex.codecogs.com/png.latex?(1-%20z_t)"> y <img src="https://latex.codecogs.com/png.latex?h_%7Bt%7D%5E%7B%5Cprime%7D">.</p></li>
<li><p>Sume los resultados de los pasos 1 y 2.</p></li>
</ol>
<p>Pongamos el ejemplo de la reseña del equilibrio. En esta ocasión, la información más relevante se situa al inicio del texto. El modelo puede aprender a establecer el vector <img src="https://latex.codecogs.com/png.latex?z_t"> cerca de 1 y conservar la mayor parte de la información anterior. Dado que <img src="https://latex.codecogs.com/png.latex?z_t"> estará cerca de 1 en este paso de tiempo, <img src="https://latex.codecogs.com/png.latex?(1-z_t)"> estará cerca de 0, lo que ignorará gran parte del contenido actual (en este caso, la última parte de la reseña que explica la trama del libro), lo cual es irrelevante para nuestra predicción.</p>
<p>Aquí hay una ilustración que enfatiza la ecuación anterior:</p>
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/fig_4_gru.png" class="img-fluid"></p>
<p>A continuación, puede ver cómo <img src="https://latex.codecogs.com/png.latex?z_t"> (línea verde) para calcular <img src="https://latex.codecogs.com/png.latex?1%20-%20z_t"> que combinado con <img src="https://latex.codecogs.com/png.latex?h_%7Bt%7D%5E%7B%5Cprime%7D"> (línea verde brillante), produce un resultado en la línea roja oscura. <img src="https://latex.codecogs.com/png.latex?z_t"> también se usa con <img src="https://latex.codecogs.com/png.latex?h_%7Bt-1%7D%20-%20%5Cmbox%7Bl%C3%ADnea%20azul%7D"> en una multiplicación de elementos. Finalmente, <img src="https://latex.codecogs.com/png.latex?h_%7Bt%7D:"> la línea azul es el resultado de la suma de las salidas correspondientes a las líneas rojas brillantes y oscuras.</p>
<p>Ahora puede ver cómo las GRU pueden almacenar y filtrar la información utilizando sus puertas de actualización y reinicio. Eso elimina el problema del gradiente de fuga, ya que el modelo no elimina la nueva entrada cada vez, sino que mantiene la información relevante y la pasa a los siguientes pasos de la red. <strong><em>Si se les entrena cuidadosamente, pueden desempeñarse extremadamente bien incluso en escenarios complejos.</em></strong></p>
<p>El modelo de predicción <code>GRU</code> es muy similar al <code>RNN</code>. Veamos su desempeño utilizando la misma data que el casa <code>RNN</code>.</p>
<div id="cb449893" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb14" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch.nn <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> nn</span>
<span id="cb14-2"></span>
<span id="cb14-3">random.seed(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb14-4">torch.manual_seed(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb14-5"></span>
<span id="cb14-6"></span>
<span id="cb14-7">features <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">240</span></span>
<span id="cb14-8">test_ts_len <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">300</span></span>
<span id="cb14-9">gru_hidden_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">24</span></span>
<span id="cb14-10">learning_rate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.02</span></span>
<span id="cb14-11">training_epochs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">500</span></span>
<span id="cb14-12"></span>
<span id="cb14-13"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> GRU(nn.Module):</span>
<span id="cb14-14"></span>
<span id="cb14-15">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>,</span>
<span id="cb14-16">                 hidden_size,</span>
<span id="cb14-17">                 in_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,</span>
<span id="cb14-18">                 out_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):</span>
<span id="cb14-19">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">super</span>(GRU, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>).<span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>()</span>
<span id="cb14-20">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.gru <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.GRU(</span>
<span id="cb14-21">            input_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> in_size,</span>
<span id="cb14-22">            hidden_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> hidden_size,</span>
<span id="cb14-23">            batch_first <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>)</span>
<span id="cb14-24">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.fc <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.Linear(hidden_size, out_size)</span>
<span id="cb14-25"></span>
<span id="cb14-26">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> forward(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, x, h <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>):</span>
<span id="cb14-27">        out, _ <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.gru(x, h)</span>
<span id="cb14-28">        last_hidden_states <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> out[:, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]</span>
<span id="cb14-29">        out <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.fc(last_hidden_states)</span>
<span id="cb14-30">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> out, last_hidden_states</span>
<span id="cb14-31"></span>
<span id="cb14-32"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Inicializando el modelo GRU</span></span>
<span id="cb14-33">model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> GRU(hidden_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> gru_hidden_size)</span>
<span id="cb14-34">model.train()</span>
<span id="cb14-35"></span>
<span id="cb14-36"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Entrenamiento</span></span>
<span id="cb14-37">optimizer <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.optim.Adam(params <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model.parameters(), lr <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> learning_rate)</span>
<span id="cb14-38">mse_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.nn.MSELoss()</span>
<span id="cb14-39"></span>
<span id="cb14-40">best_model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span></span>
<span id="cb14-41">min_val_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sys.maxsize</span>
<span id="cb14-42"></span>
<span id="cb14-43">training_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb14-44">validation_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb14-45"></span>
<span id="cb14-46"></span>
<span id="cb14-47"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> t <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(training_epochs):</span>
<span id="cb14-48"></span>
<span id="cb14-49">    prediction, _ <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model(x_train)</span>
<span id="cb14-50">    loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> mse_loss(prediction, y_train)</span>
<span id="cb14-51"></span>
<span id="cb14-52">    optimizer.zero_grad()</span>
<span id="cb14-53">    loss.backward()</span>
<span id="cb14-54">    optimizer.step()</span>
<span id="cb14-55"></span>
<span id="cb14-56">    val_prediction, _ <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model(x_val)</span>
<span id="cb14-57">    val_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> mse_loss(val_prediction, y_val)</span>
<span id="cb14-58"></span>
<span id="cb14-59">    training_loss.append(loss.item())</span>
<span id="cb14-60">    validation_loss.append(val_loss.item())</span>
<span id="cb14-61"></span>
<span id="cb14-62">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> val_loss.item() <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> min_val_loss:</span>
<span id="cb14-63">        best_model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> copy.deepcopy(model)</span>
<span id="cb14-64">        min_val_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> val_loss.item()</span>
<span id="cb14-65"></span>
<span id="cb14-66">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> t <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">50</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:</span>
<span id="cb14-67">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f'epoch </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>t<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: train - </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">round</span>(loss.item(), <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>)<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">, '</span></span>
<span id="cb14-68">              <span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f'val: - </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">round</span>(val_loss.item(), <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>)<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span>)</span>
<span id="cb14-69"></span>
<span id="cb14-70">best_model.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">eval</span>()</span>
<span id="cb14-71">_, h_list <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> best_model(x_val)</span>
<span id="cb14-72">h <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (h_list[<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, :]).unsqueeze(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span>
<span id="cb14-73"></span>
<span id="cb14-74">predicted <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb14-75"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> test_seq <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> x_test.tolist():</span>
<span id="cb14-76">    x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.Tensor(data <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [test_seq])</span>
<span id="cb14-77">    y, h <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> best_model(x, h.unsqueeze(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>))</span>
<span id="cb14-78">    unscaled <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> scaler.inverse_transform(np.array(y.item()).reshape(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>))[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>][<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb14-79">    predicted.append(unscaled)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>epoch 0: train - 0.0626, val: - 0.0326
epoch 50: train - 0.0017, val: - 0.0026
epoch 100: train - 0.0012, val: - 0.0024
epoch 150: train - 0.0012, val: - 0.0023
epoch 200: train - 0.0011, val: - 0.0022
epoch 250: train - 0.0011, val: - 0.0022
epoch 300: train - 0.0011, val: - 0.0023
epoch 350: train - 0.0011, val: - 0.0023
epoch 400: train - 0.0011, val: - 0.0022
epoch 450: train - 0.0011, val: - 0.0022</code></pre>
</div>
</div>
<div id="37398aa5" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb16" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1">real <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> scaler.inverse_transform(y_test.tolist())</span>
<span id="cb16-2">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Conjunto de datos prueba - GRU"</span>)</span>
<span id="cb16-3">plt.plot(real, label <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'real'</span>)</span>
<span id="cb16-4">plt.plot(predicted, label <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'predicción'</span>)</span>
<span id="cb16-5">plt.legend()</span>
<span id="cb16-6">plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/index_files/figure-html/cell-13-output-1.png" width="592" height="431" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Vemos que el modelo <code>GRU</code> imita el comportamiento original de la serie temporal con bastante precisión.</p>
<div id="d4ec6b8b" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb17" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Desempeño GRU'</span>)</span>
<span id="cb17-2">plt.yscale(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'log'</span>)</span>
<span id="cb17-3">plt.plot(training_loss, label <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Entrenamiengto'</span>)</span>
<span id="cb17-4">plt.plot(validation_loss, label <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'validación'</span>)</span>
<span id="cb17-5">plt.ylabel(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Loss'</span>)</span>
<span id="cb17-6">plt.xlabel(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Epoch'</span>)</span>
<span id="cb17-7">plt.legend()</span>
<span id="cb17-8">plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/index_files/figure-html/cell-14-output-1.png" width="599" height="450" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Las pérdidas de entrenamiento y validación tienen descenso asintótico con un brecha natural constante entre ellas. Podemos concluir que el modelo realmente aprende el comportamiento de la serie temporal.</p>
</section>
<section id="long-short-term-memory-network-lstm" class="level3">
<h3 class="anchored" data-anchor-id="long-short-term-memory-network-lstm">Long short-term memory network (LSTM)</h3>
<p>La red <code>LSTM</code> se ha desarrollado para superar el problema de fuga de gradiente en <code>RNN</code> al mejorar el flujo de gradiente de la red. Debe mencionarse que la arquitectura apareció mucho antes que la GRU. La arquitectura LSTM se desarrolló en 1997, y el GRU se propueso en 2014. El diseño GRU es más simple y más comprensible que LSTM. Es por eso que comenzamos nuestro estudio examinando primero GRU.</p>
<p>Como su nombre lo índica, LSTM aborda los mismos problemas de memoria a corto y largo plazo que GRU. A nivel global, el flujo computacional del LSTM se ve de la siguiente manera:</p>
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/Figure 4.16.png" class="img-fluid"></p>
<p>LSTM funciona sobre los principios similares que GRU pero tiene más variables. RNN y GRU solo pasan un estado oculto <img src="https://latex.codecogs.com/png.latex?h_t"> a través de cada iteración. Pero LSTM pasa dos vectores:</p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?h_t"> estado oculto (memoria a corto plazo)</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?c_t"> estado de celda (memoria a largo plazo)</p></li>
</ul>
<p>Las salidas de <code>LSTM Cell</code> se calculan a través de las fórmulas:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Beqnarray*%7D%0Ai_t%20&amp;=&amp;%20%5Csigma(W_%7Bii%7Dx_t%20+%20b_%7Bii%7D%20+%20W_%7Bhi%7Dh_%7Bt-1%7D%20+%20b_%7Bhi%7D)%5C%5C%5B0.2cm%5D%0Af_t%20&amp;=&amp;%20%5Csigma(W_%7Bii%7Dx_%7Bt%7D%20+%20b_%7Bif%7D%20+%20W_%7Bhf%7Dh_%7Bt-1%7D%20+%20b_%7Bhf%7D)%5C%5C%5B0.2cm%5D%0Ag_t%20&amp;=&amp;%20tanh(W_%7Big%7Dx_t%20+%20b_%7Big%7D%20+%20W_%7Bhg%7Dh_%7Bt-1%7D%20+%20b_%7Bhn%7D)%5C%5C%5B0.2cm%5D%0Ao_t%20&amp;=&amp;%20%5Csigma(W_%7Bio%7Dx_t%20+%20b_%7Bio%7D%20+%20W_%7Bho%7Dh_%7Bt-1%7D%20+%20b_%7Bho%7D)%5C%5C%5B0.2cm%5D%0Ac_t%20&amp;=&amp;%20f_t%20%5Ccirc%20c_%7Bt-1%7D%20+%20i_t%5Ccirc%20g_t%5C%5C%5B0.2cm%5D%0Ah_t%20&amp;=&amp;%20o_t%20%5Ccirc%20tanh(c_t)%0A%5Cend%7Beqnarray*%7D%0A"></p>
<p>donde:</p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?%5Csigma"> es la función sigmoidea</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?%5Ccirc"> es el producto de Hadamard</p></li>
</ul>
<p>En cuanto a las variables:</p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?i_t~(puerta%20de%20entrada)"> es la variable que se utiliza para actualizar el estado <img src="https://latex.codecogs.com/png.latex?c_t">. El estado previamente oculto <img src="https://latex.codecogs.com/png.latex?h_t"> y la secuencia <img src="https://latex.codecogs.com/png.latex?x_t"> se dan como entradas a una función sigmoidea <img src="https://latex.codecogs.com/png.latex?(%5Csigma)">. Si la salida está cerca de 1, entonces la información es más importante.</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?f_t%20~%20(puerta~de~olvido)"> es la variable que decide que información debe olvidarse en el estado <img src="https://latex.codecogs.com/png.latex?c_t">. El estado <img src="https://latex.codecogs.com/png.latex?h_t"> de estado previamente oculto y la secuencia <img src="https://latex.codecogs.com/png.latex?x_t"> se dan como entradas a una función sigmoidea. Si la salida <img src="https://latex.codecogs.com/png.latex?f_t"> está cerca de cero, la información se puede olvidar, mientras que si la salida está cerca de 1, la información debe almacenarse o recordarse.</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?g_t"> representa información importante potencialmente nueva para el estado <img src="https://latex.codecogs.com/png.latex?c_t">.</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?c_t%20~%20(estado~celda)"> es una suma de:</p>
<ul>
<li><p>estado de celda anterior <img src="https://latex.codecogs.com/png.latex?c_%7Bt-1%7D"> con información olvidada <img src="https://latex.codecogs.com/png.latex?f_t">.</p></li>
<li><p>nueva información de <img src="https://latex.codecogs.com/png.latex?g_t"> seleccionada por <img src="https://latex.codecogs.com/png.latex?i_t"></p></li>
</ul></li>
<li><p><img src="https://latex.codecogs.com/png.latex?o_t%20~%20(puerta~de~salida)"> es la variable para actualizar el estado oculto <img src="https://latex.codecogs.com/png.latex?h_t">.</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?h_t%20~(estado~oculto)"> es el siguiente estado oculto que se calcula eligiendo la información importante del estado de celda o celular <img src="https://latex.codecogs.com/png.latex?c_t">.</p></li>
</ul>
<p>A continuación te muestro el gráfico computacional de la celda LSTM:</p>
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/Figure 4.17 .png" class="img-fluid"></p>
<p>LSTM tiene los siguientes parámetros, que se ajustan durante el entrenamiento:</p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?W_%7Bii%7D,%20W_%7Bhi%7D,%20W_%7Bif%7D,%20W_%7Bhf%7D,%20W_%7Big%7D,%20W_%7Bhg%7D,%20W_%7Bio%7D,%20W_%7Bho%7D"> estos son los pesos.</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?b_%7Bii%7D,%20b_%7Bhi%7D,%20b_%7Bif%7D,%20b_%7Bhf%7D,%20b_%7Big%7D,%20b_%7Bhg%7D,%20b_%7Bio%7D,%20b_%7Bho%7D"> estos son sesgos.</p></li>
</ul>
<p>Ahora examinemos la implementación de Pytorch del modelo de predicción LSTM:</p>
<div id="27a76060" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb18" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch.nn <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> nn</span>
<span id="cb18-2"></span>
<span id="cb18-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> LSTM(nn.Module):</span>
<span id="cb18-4"></span>
<span id="cb18-5">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>,</span>
<span id="cb18-6">                 hidden_size,</span>
<span id="cb18-7">                 in_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,</span>
<span id="cb18-8">                 out_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):</span>
<span id="cb18-9">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">super</span>(LSTM, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>).<span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>()</span>
<span id="cb18-10">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.lstm <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.LSTM(</span>
<span id="cb18-11">            input_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> in_size,</span>
<span id="cb18-12">            hidden_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> hidden_size,</span>
<span id="cb18-13">            batch_first <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>)</span>
<span id="cb18-14">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.fc <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.Linear(hidden_size, out_size)</span>
<span id="cb18-15"></span>
<span id="cb18-16">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> forward(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, x, h <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>):</span>
<span id="cb18-17">        out, h <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.lstm(x, h)</span>
<span id="cb18-18">        last_hidden_states <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> out[:, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]</span>
<span id="cb18-19">        out <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.fc(last_hidden_states)</span>
<span id="cb18-20">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> out, h</span></code></pre></div>
</div>
<p>Como vemos, la implementación del modelo <code>LSTM</code> es bastante similar a las implementaciones de <code>RNN</code> y <code>GRU</code>.</p>
<p>Probaremos el modelo LSTM con el siguiente conjunto de datos de la serie tiempo de consumo de energía por hora).</p>
<div id="513d0ebd" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb19" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> pandas <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> pd</span>
<span id="cb19-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch</span>
<span id="cb19-3"></span>
<span id="cb19-4">df <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> pd.read_csv(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'NI_hourly.csv'</span>)</span>
<span id="cb19-5">ts <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> df[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'NI_MW'</span>].astype(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>).values.reshape(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)[<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3000</span>:]</span>
<span id="cb19-6"></span>
<span id="cb19-7"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> matplotlib.pyplot <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> plt</span>
<span id="cb19-8"></span>
<span id="cb19-9">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'NI Hourly'</span>)</span>
<span id="cb19-10">plt.plot(ts[:<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">500</span>])</span>
<span id="cb19-11">plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/index_files/figure-html/cell-16-output-1.png" width="592" height="431" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Veamos el modelo en acción:</p>
<div id="4b122770" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb20" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> copy</span>
<span id="cb20-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> random</span>
<span id="cb20-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> sys</span>
<span id="cb20-4"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb20-5"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> matplotlib.pyplot <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> plt</span>
<span id="cb20-6"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch</span>
<span id="cb20-7"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sklearn.preprocessing <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> MinMaxScaler</span>
<span id="cb20-8"></span>
<span id="cb20-9">random.seed(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb20-10">torch.manual_seed(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb20-11"></span>
<span id="cb20-12"></span>
<span id="cb20-13">features <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">240</span></span>
<span id="cb20-14">test_ts_len <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">300</span></span>
<span id="cb20-15">lstm_hidden_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">24</span></span>
<span id="cb20-16">learning_rate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.02</span></span>
<span id="cb20-17">training_epochs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span></span>
<span id="cb20-18"></span>
<span id="cb20-19"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Preparar el conjunto de datos para el entrenamiento </span></span>
<span id="cb20-20">scaler <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> MinMaxScaler()</span>
<span id="cb20-21">scaled_ts <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> scaler.fit_transform(ts)</span>
<span id="cb20-22">x_train, x_val, x_test, y_train, y_val, y_test <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=\</span></span>
<span id="cb20-23">    get_training_datasets(scaled_ts, features, test_ts_len)</span>
<span id="cb20-24"></span>
<span id="cb20-25"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Inicializando el modelo </span></span>
<span id="cb20-26">model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> LSTM(hidden_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> lstm_hidden_size)</span>
<span id="cb20-27">model.train()</span>
<span id="cb20-28"></span>
<span id="cb20-29"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Entrenamiento </span></span>
<span id="cb20-30">optimizer <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.optim.Adam(params <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model.parameters(), lr <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> learning_rate)</span>
<span id="cb20-31">mse_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.nn.MSELoss()</span>
<span id="cb20-32"></span>
<span id="cb20-33">best_model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span></span>
<span id="cb20-34">min_val_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sys.maxsize</span>
<span id="cb20-35"></span>
<span id="cb20-36">training_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb20-37">validation_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb20-38"></span>
<span id="cb20-39"></span>
<span id="cb20-40"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> t <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(training_epochs):</span>
<span id="cb20-41"></span>
<span id="cb20-42">    prediction, _ <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model(x_train)</span>
<span id="cb20-43">    loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> mse_loss(prediction, y_train)</span>
<span id="cb20-44"></span>
<span id="cb20-45">    optimizer.zero_grad()</span>
<span id="cb20-46">    loss.backward()</span>
<span id="cb20-47">    optimizer.step()</span>
<span id="cb20-48"></span>
<span id="cb20-49">    val_prediction, _ <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model(x_val)</span>
<span id="cb20-50">    val_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> mse_loss(val_prediction, y_val)</span>
<span id="cb20-51"></span>
<span id="cb20-52">    training_loss.append(loss.item())</span>
<span id="cb20-53">    validation_loss.append(val_loss.item())</span>
<span id="cb20-54"></span>
<span id="cb20-55">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> val_loss.item() <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> min_val_loss:</span>
<span id="cb20-56">        best_model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> copy.deepcopy(model)</span>
<span id="cb20-57">        min_val_loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> val_loss.item()</span>
<span id="cb20-58"></span>
<span id="cb20-59">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> t <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:</span>
<span id="cb20-60">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f'epoch </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>t<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: train - </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">round</span>(loss.item(), <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>)<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">, '</span></span>
<span id="cb20-61">              <span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f'val: - </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">round</span>(val_loss.item(), <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>)<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>epoch 0: train - 0.0979, val: - 0.087
epoch 10: train - 0.0253, val: - 0.0255
epoch 20: train - 0.0131, val: - 0.0119
epoch 30: train - 0.0056, val: - 0.0059
epoch 40: train - 0.0032, val: - 0.0043
epoch 50: train - 0.0026, val: - 0.0029
epoch 60: train - 0.002, val: - 0.0025
epoch 70: train - 0.0018, val: - 0.0023
epoch 80: train - 0.0016, val: - 0.0021
epoch 90: train - 0.0014, val: - 0.0019</code></pre>
</div>
</div>
<p>Para una evaluación del modelo LSTM, necesitamos pasar un estado celular y estado oculto.</p>
<div id="96c8f158" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb22" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1">best_model.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">eval</span>()</span>
<span id="cb22-2"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">with</span> torch.no_grad():</span>
<span id="cb22-3">    _, h_list <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> best_model(x_val)</span>
<span id="cb22-4"></span>
<span id="cb22-5">    h <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">tuple</span>([(h[<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, :]).unsqueeze(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>).unsqueeze(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span>
<span id="cb22-6">               <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> h <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> h_list])</span>
<span id="cb22-7"></span>
<span id="cb22-8">    predicted <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb22-9">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> test_seq <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> x_test.tolist():</span>
<span id="cb22-10">        x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.Tensor(data <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [test_seq])</span>
<span id="cb22-11"></span>
<span id="cb22-12">        y, h <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> best_model(x, h)</span>
<span id="cb22-13">        unscaled <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> scaler.inverse_transform(</span>
<span id="cb22-14">            np.array(y.item()).reshape(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>))[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>][<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb22-15">        predicted.append(unscaled)</span>
<span id="cb22-16">        </span>
<span id="cb22-17">real <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> scaler.inverse_transform(y_test.tolist())</span>
<span id="cb22-18">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Conjunto de prueba - LSTM"</span>)</span>
<span id="cb22-19">plt.plot(real, label <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'real'</span>)</span>
<span id="cb22-20">plt.plot(predicted, label <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'predicción'</span>)</span>
<span id="cb22-21">plt.legend()</span>
<span id="cb22-22">plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/index_files/figure-html/cell-18-output-1.png" width="592" height="431" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>LSTM captura muy bien el comportamiento de las series temporales para hacer predicciones precisas.</p>
<div id="05deeba6" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb23" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Desempeño LSTM'</span>)</span>
<span id="cb23-2">plt.yscale(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'log'</span>)</span>
<span id="cb23-3">plt.plot(training_loss, label <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Entrenamiento'</span>)</span>
<span id="cb23-4">plt.plot(validation_loss, label <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'validación'</span>)</span>
<span id="cb23-5">plt.ylabel(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Loss'</span>)</span>
<span id="cb23-6">plt.xlabel(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Epoch'</span>)</span>
<span id="cb23-7">plt.legend()</span>
<span id="cb23-8">plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/Neural Network/index_files/figure-html/cell-19-output-1.png" width="599" height="450" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Mirando, concluimos que detuvimos el proceso de entrenamiento demasiado temprano. Obtenemos modelos más precisos si establecemos más epocas (epoch) para el entrenamiento.</p>
</section>
<section id="conclusiones" class="level3">
<h3 class="anchored" data-anchor-id="conclusiones">CONCLUSIONES</h3>
<p>Pudimos ver que las redes neuronales recurrentes muestran excelentes resultados y son adecuadas para problemas de pronósticos de series de tiempo.</p>
<p>Las Redes Neuronales Recurrentes son la técnica muy popular de aprendizaje profundo (Deep Learning) para el pronóstico de series de tiempo, ya que permiten producir predicciones confiables en series de tiempo en diversos problemas. El principal problema con RNN es que sufre el problema de fuga de gradiente cuando se aplica a secuencia largas, y no tiene una herramienta de memoria a largo plazo. Se desarrollaron LSTM y GRU para evitar el problema de gradiente de RNN con el uso de puertas que regulan el flujo de información e implementan el almacenamiento de memoria a largo plazo. El uso de LSTM y GRU ofrece resultados notables, pero LSTM y GRU no siempre funcionan mejor que RNN.</p>
<ul>
<li><p><code>RNN</code> tiene un estado oculto que puede tratarse como una memoria interna de la secuencia de entrada.</p></li>
<li><p><code>RNN</code> vuelve a calcular el estado oculto después de procesar cada nuevo valor de entrada de forma recurrente.</p></li>
<li><p><code>RNN</code> sufre un problema de fuga de gradiente.</p></li>
<li><p><code>RNN</code> actualiza un estado oculto en cada iteración. Por tanto, no tiene memoria a largo plazo.</p></li>
<li><p><code>GRU</code> implementa la puerta de reinicio, que rechaza algunas actualizaciones en un estado oculto.</p></li>
<li><p><code>LSTM</code> pasa dos vectores a través de cada iteración: <em>estado oculto</em> y <em>estado de celda.</em></p></li>
</ul>
</section>
<section id="referencias" class="level3">
<h3 class="anchored" data-anchor-id="referencias">REFERENCIAS</h3>
<ul>
<li><p>Time Series Forecasting Using Deep Learning - Ivan Gridin</p></li>
<li><p><a href="https://towardsdatascience.com/understanding-gru-networks-2ef37df6c9be">Understanding GRU Networks</a></p></li>
</ul>
</section>
<section id="section" class="level3">
<h3 class="anchored" data-anchor-id="section"></h3>


</section>
</section>

 ]]></description>
  <category>RNN</category>
  <category>GRU</category>
  <category>LSTM</category>
  <category>PyTorch</category>
  <guid>https://j-isaula.github.io/Web_JI/posts/Neural Network/</guid>
  <pubDate>Wed, 24 Jan 2024 06:00:00 GMT</pubDate>
  <media:content url="https://j-isaula.github.io/Web_JI/posts/Neural Network/arq_rn.jpeg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>Estructuras de Mercado con Python</title>
  <dc:creator>Juan Isaula</dc:creator>
  <link>https://j-isaula.github.io/Web_JI/posts/estructuras_mercado/</link>
  <description><![CDATA[ 




<p>Este post tiene como objetivo dar a conocer la importancia del <code>software</code> de <code>Python</code> en el ambito microeconomico, particularmente en este caso hablamos de las diferentes <code>estructuras de mercado</code>; <code>competencia perfecta</code>, <code>monopolio</code> y <code>oligopolio</code>.</p>
<section id="qué-aprenderá" class="level3">
<h3 class="anchored" data-anchor-id="qué-aprenderá">Qué aprenderá</h3>
<ul>
<li><p>El comportamiento de la industria en el <strong>corto plazo</strong> y en el <strong>largo plazo</strong></p></li>
<li><p><strong>Curva de oferta de la industria</strong> a corto plazo y largo plazo</p></li>
</ul>
</section>
<section id="competencia-perfecta" class="level1">
<h1>Competencia Perfecta</h1>
<p>Un <strong>productor precio-aceptante</strong> es aquel cuyas acciones no tienen efecto sobre el precio de mercado del bien que vende</p>
<p>Un <strong>consumidor precio-aceptante</strong> es aquel cuyas acciones no tienen efecto sobre el precio de mercado del bien que compra.</p>
<p>Un <strong>mercado perfectamente competitivo</strong> es quel en el cual todos los participantes son precio-aceptantes.</p>
<p>Una <strong>industria perfectamente competitiva</strong> es aquella en la cual los productores son precio-aceptantes.</p>
<section id="condiciones-necesaria-para-la-competencia-perfecta" class="level2">
<h2 class="anchored" data-anchor-id="condiciones-necesaria-para-la-competencia-perfecta">Condiciones necesaria para la competencia perfecta</h2>
<ul>
<li><p>Muchos productores, ninguno de los cuales tiene una gran cuota de mercado.</p></li>
<li><p>Una industria puede ser perfectamente competitiva sólo si los consumidores consideran como equivalentes a los productos de todos los productores (<strong>producto homogéneo</strong>)</p></li>
</ul>
</section>
<section id="libre-entrada-y-salida" class="level2">
<h2 class="anchored" data-anchor-id="libre-entrada-y-salida">Libre entrada y salida</h2>
<p>Existe <strong>libre entrada y salida en una industria</strong> cuando nuevos productores pueden entrar facilmente en esa industria a los que ya estan en ella pueden abondonarla sin coste alguno.</p>
<section id="regla-de-producción-optima" class="level3">
<h3 class="anchored" data-anchor-id="regla-de-producción-optima">Regla de Producción Optima</h3>
<p>La <strong>regla de producción optima</strong> dice que el beneficio se maximiza cuando se produce la cantidad de output para la cual el ingreso marginal de la última unidad de output producida es igual a su coste marginal.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AIMg%20=%20CMg%0A"></p>
</section>
<section id="función-de-benenficios" class="level3">
<h3 class="anchored" data-anchor-id="función-de-benenficios">Función de Benenficios</h3>
<p>La función de beneficios <img src="https://latex.codecogs.com/png.latex?(%5Cpi)"> representa las diferencias entre los costos totales, <img src="https://latex.codecogs.com/png.latex?C(Q)"> e ingresos totales,<img src="https://latex.codecogs.com/png.latex?R(Q)"> , de las empresas</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cpi%20=%20R(Q)%20-%20C(Q)%0A"></p>
</section>
<section id="tomador-de-precios" class="level3">
<h3 class="anchored" data-anchor-id="tomador-de-precios">Tomador de Precios</h3>
<p>Precio igual al costo marginal</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Beqnarray*%7D%0ACMg%20=%20IMg%20=%20P%0A%5Cend%7Beqnarray*%7D%0A"></p>
<p>Por tanto, se dice que el beneficio de una empresa precio-aceptante se maximiza produciendo la cantidad de output para la cual el costo marginal de la última unidad producida es igual al precio de mercado, tal como se aprecia en el siguiente gráfico</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/estructuras_mercado/equilibrio.jpeg" class="img-fluid figure-img"></p>
<figcaption>Cantidad de producto que maximiza el beneficio de una empresa precio-aceptante</figcaption>
</figure>
</div>
</section>
</section>
<section id="costes-y-producción-en-el-corto-plazo" class="level2">
<h2 class="anchored" data-anchor-id="costes-y-producción-en-el-corto-plazo">Costes y Producción en el Corto Plazo</h2>
<p>En el corto plazo tenemos las siguientes condiciones de producción de empresas competitivas</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 92%">
</colgroup>
<thead>
<tr class="header">
<th>Condiciones</th>
<th>Resultados</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>P &gt; CVMe mínimo</td>
<td>La empresa produce en el corto plazo. Si P &lt; CTMe mínimo, la empresa cubre sus costos variables y parte de sus costes fijos pero no todos. Si P &gt; CTMe mínimo, la empresa cubre todos sus costes variables y sus costes fijos.</td>
</tr>
<tr class="even">
<td>P = CVMe mínimo</td>
<td>La empresa es indiferente entre producir en el corto plazo o no producir. Cubre exactamente sus costes variables.</td>
</tr>
<tr class="odd">
<td>P &lt; CVMe mínimo</td>
<td>La empresa cierra en el corto plazo. No cubre sus costes variables.</td>
</tr>
</tbody>
</table>
</section>
<section id="ejemplo-1--corto-plazo" class="level2">
<h2 class="anchored" data-anchor-id="ejemplo-1--corto-plazo">Ejemplo # 1- Corto Plazo</h2>
<p>Primero resolveremos el siguiente ejercicio de manera manual y posteriormente lo resolveremos en Python.</p>
<p>Suponga que la empresa tiene una curva de costos de corto plazo dada por</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AC(Q)%20=%20100%20+%2020Q%20+%20Q%5E2%0A"></p>
<ul>
<li><p>¿Cuál es la ecuación para el costo variable Medio?</p></li>
<li><p>¿Cuál es el valor mínimo para el costo variable promedio?</p></li>
<li><p>¿Cuál es la curva de oferta de corto plazo?</p></li>
</ul>
<p><strong><em>Solución</em></strong></p>
<ul>
<li><p>Dada la función de costo <img src="https://latex.codecogs.com/png.latex?C(Q)%20=%20100%20+%2020Q%20+%20Q%5E2"> es claro que el costo variable, CV, esta dado por <img src="https://latex.codecogs.com/png.latex?CV%20=%2020Q%20+%20Q%5E2"> por tanto su costo variable promedio es <img src="https://latex.codecogs.com/png.latex?CVMe%20=%20%5Cfrac%7BCV%7D%7BQ%7D%20=%2020%20+%20Q"></p></li>
<li><p>Ahora bien, su costo marginal sabemos que unicamente requiere aplicar la regla de diferenciación, ya que <img src="https://latex.codecogs.com/png.latex?CMg%20=%20%5Cfrac%7B%5Cpartial%20C(Q)%7D%7B%5Cpartial%20Q%7D%20=%2020%20+%202Q"></p></li>
<li><p>Si queremos encontrar el costo variable promedio mínimo, <img src="https://latex.codecogs.com/png.latex?CVMe_%7B%5Cmin%7D">, se obtiene como <img src="https://latex.codecogs.com/png.latex?CMg%20=%20CVMe%20%5Clongrightarrow%20Q%20=%20%5Cfbox%7B0%7D"></p></li>
<li><p>Entonces la función de oferta es: <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Beqnarray*%7DCMg%20&amp;=&amp;%20p%5C%5C%5B0.2cm%5D%2020%20+%202Q%20&amp;=&amp;%20P%5C%5C%5B0.2cm%5D%20Q(P)%20&amp;=&amp;%20%5Cfrac%7BP%7D%7B2%7D%20-%2010%20%5Cend%7Beqnarray*%7D"></p></li>
</ul>
<p>Por tanto, también podemos obtener el precio de equilibrio, ya que <img src="https://latex.codecogs.com/png.latex?0%20=%20%5Cfrac%7BP%7D%7B2%7D%20-%2010%20%5Clongrightarrow%20P%20=%20%5Cfbox%7B20%7D"></p>
<p>Ahora, encontremos estos resultados en Python:</p>
<div id="dd645751" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Paquete previo </span></span>
<span id="cb1-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sympy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span></span>
<span id="cb1-3">Q <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> symbols(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Q"</span>)</span>
<span id="cb1-4"></span>
<span id="cb1-5"></span>
<span id="cb1-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># función de costo de corto plazo </span></span>
<span id="cb1-7">CT <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">20</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>Q <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> Q<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">**</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span></span>
<span id="cb1-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># costo variale promedio </span></span>
<span id="cb1-9">CV <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">20</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> Q </span>
<span id="cb1-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Encontrar el costo variable minimo </span></span>
<span id="cb1-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Primero: costo marginal</span></span>
<span id="cb1-12"></span>
<span id="cb1-13">CM <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> diff(CT,Q)</span></code></pre></div>
</div>
<div id="fa46cc9d" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># igualar costo marginal y costo variable promedio </span></span>
<span id="cb2-2">solve(Eq(CM,CV))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>[0]</code></pre>
</div>
</div>
<div id="a6e38a40" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1">cantidad <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> solve(Eq(CM,CV))</span>
<span id="cb4-2">cantidad[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span></code></pre></div>
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="3">
<p><img src="https://latex.codecogs.com/png.latex?%5Cdisplaystyle%200"></p>
</div>
</div>
<div id="b9a8d7cb" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1">P <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> CV.subs({Q:cantidad[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]})</span>
<span id="cb5-2">P</span></code></pre></div>
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="4">
<p><img src="https://latex.codecogs.com/png.latex?%5Cdisplaystyle%2020"></p>
</div>
</div>
<div id="895979f1" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1">plot(CT, CT<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>Q, CV, CM, (Q,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>), xlim <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>), ylim <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>), xlabel <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Q"</span>, ylabel <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"P"</span>)</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/estructuras_mercado/index_files/figure-html/cell-6-output-1.png" width="661" height="468" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Puedes notar lo rápido y fácil que resulta realizar estos procedimientos con Python y la utilidad que puede brindarte en caso de que trabajes con volumnes de datos.</p>
<section id="ejemplo-2---corto-plazo" class="level3">
<h3 class="anchored" data-anchor-id="ejemplo-2---corto-plazo">Ejemplo # 2 - Corto Plazo</h3>
<p>Ahora suponga que la empresa tiene una curva costos en el corto plazo de la siguiente forma:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AC(Q)%20=%201%20+%2010Q%20+%20Q%5E2%0A"></p>
<p>Si la empresa opera en un mercado perfectamente competitivo, donde <img src="https://latex.codecogs.com/png.latex?P%20=%2012">, ¿Cuál será los beneficios de la empresa en el corto plazo?</p>
<p><strong><em>Solución</em></strong></p>
<p>Sabemos que la función de beneficios esta dada por</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cpi%20=%20R%20-%20C%0A"></p>
<p>entonces,</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B%5Cpartial%20%5Cpi%7D%7B%5Cpartial%20Q%7D%20=%20IMg%20-%20CMg%20=%200%0A"></p>
<p>así pues,</p>
<p><img src="https://latex.codecogs.com/png.latex?%0ACMg%20=%2010%20+%202Q%20%5Chspace%7B1cm%7Dy%5Chspace%7B1cm%7D%20IMg%20=%20P%0A"></p>
<p>por tanto,</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Beqnarray*%7D%0ACMg%20&amp;=&amp;%20IMg%5C%5C%5B0.2cm%5D%0A10%20+%202Q%20&amp;=&amp;%20P%5C%5C%5B0.2cm%5D%0AQ%20&amp;=&amp;%20%5Cfrac%7BP%7D%7B2%7D%20-%205%5C%5C%5B0.2cm%5D%0AQ%20&amp;=&amp;%20%5Cfrac%7B12%7D%7B2%7D%20-%205,%20%5Chspace%7B2cm%7D%5Cmbox%7Bya%20que%20P%20=%2012%7D%5C%5C%5B0.2cm%5D%0AQ%20&amp;=&amp;%20%5Cfbox%7B1%7D%0A%5Cend%7Beqnarray*%7D%0A"></p>
<p>entonces,</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cpi%20=%2012%20-%20(1%20+%2010%20+1)%20=%20%5Cfbox%7B0%7D%0A"></p>
<p>Ahora veamos esta solución en Python:</p>
<div id="ad14319e" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Función de costos a corto plazo </span></span>
<span id="cb7-2">Q <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> symbols(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Q"</span>)</span>
<span id="cb7-3">CT <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Q<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">**</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>Q <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb7-4">P <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">12</span></span>
<span id="cb7-5">R <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> P<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>Q</span>
<span id="cb7-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># costo marginal</span></span>
<span id="cb7-7">CM <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> diff(CT,Q)</span>
<span id="cb7-8">CM</span>
<span id="cb7-9">IM <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> diff(R,Q)</span>
<span id="cb7-10">IM</span>
<span id="cb7-11">cantidad <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> solve(Eq(IM,CM))</span>
<span id="cb7-12"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"El valor de la producción que garantiza un equilibrio será:"</span>, cantidad[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>])</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>El valor de la producción que garantiza un equilibrio será: 1</code></pre>
</div>
</div>
<p>Este resultado lo que nos dice es que la empresa oferta una unidad de producción <img src="https://latex.codecogs.com/png.latex?Q%20=%201">.</p>
<div id="3dd27918" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Beneficio = IT - CT</span></span>
<span id="cb9-2">costo <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> CT.subs({Q:cantidad[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]})</span>
<span id="cb9-3">costo</span></code></pre></div>
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="7">
<p><img src="https://latex.codecogs.com/png.latex?%5Cdisplaystyle%2012"></p>
</div>
</div>
<div id="d29cf838" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1">ingreso <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> R.subs({Q:cantidad[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]})</span>
<span id="cb10-2">ingreso </span></code></pre></div>
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="8">
<p><img src="https://latex.codecogs.com/png.latex?%5Cdisplaystyle%2012"></p>
</div>
</div>
<div id="73cc829c" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1">Beneficios <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> R <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> CT</span>
<span id="cb11-2">pi <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Beneficios.subs({Q:cantidad[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]})</span>
<span id="cb11-3">pi</span></code></pre></div>
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="9">
<p><img src="https://latex.codecogs.com/png.latex?%5Cdisplaystyle%200"></p>
</div>
</div>
<div id="8d31cb16" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb12" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1">plot(CT,CM,CT<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>Q,(Q,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">60</span>), xlim<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>), ylim<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">30</span>), xlabel<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Q'</span>, ylabel<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'CT,CM'</span>)</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://j-isaula.github.io/Web_JI/posts/estructuras_mercado/index_files/figure-html/cell-11-output-1.png" width="661" height="468" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Recuerde que todo este análisis se realizo para un mercado en competencia perfecta a corto plazo.</p>
<p><code>Pronto actualizare para el mercado en competencia perfecta a largo plazo, monopolio, e introducirnos un poco a la teoria de juegos.</code></p>


</section>
</section>
</section>

 ]]></description>
  <category>CMg</category>
  <category>CVP</category>
  <category>CTP</category>
  <category>Python</category>
  <guid>https://j-isaula.github.io/Web_JI/posts/estructuras_mercado/</guid>
  <pubDate>Thu, 13 Apr 2023 06:00:00 GMT</pubDate>
  <media:content url="https://j-isaula.github.io/Web_JI/posts/estructuras_mercado/estruct_mercd.jpeg" medium="image" type="image/jpeg"/>
</item>
</channel>
</rss>
